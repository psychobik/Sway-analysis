<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>SwayMed — Stability Fixes</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
:root{--accent:#5b6cff;--muted:#6b7280}
body{font-family:Arial, Helvetica, sans-serif;background:#f4f8ff;margin:0;color:#042028}
.container{max-width:920px;margin:12px auto;padding:12px}
.header{display:flex;align-items:center;gap:12px;padding:12px}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7c4dff);color:white;display:flex;align-items:center;justify-content:center;font-weight:700}
.grid{display:grid;grid-template-columns:360px 1fr;gap:12px}
.card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(12,30,50,0.06)}
#videoArea{position:relative;border-radius:8px;overflow:hidden;background:#000;height:420px}
video, canvas{width:100%;height:100%;display:block;object-fit:cover}
.controls{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.row{display:flex;gap:8px;align-items:center}
.btn{padding:10px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.primary{background:linear-gradient(90deg,var(--accent),#7c4dff);color:white}
.small{font-size:13px;color:#58606a}
.metric{padding:8px;background:#fbfdff;border-radius:8px;text-align:center}
.plot{background:#fff;border-radius:8px;padding:8px}
.footer{font-size:13px;color:#6b7280;margin-top:8px}
.slider{width:140px}
</style>
</head>
<body>
<div class="container">
  <div class="header"><div class="logo">S</div><div><strong>SwayMed — Stability Fixes</strong><div class="small">Improved marker recovery, smoothing, sensitivity control</div></div></div>

  <div class="grid">
    <div class="card">
      <strong>Live Camera & Controls</strong>
      <div id="videoArea" style="margin-top:8px">
        <!-- SINGLE video preview and single overlay canvas (only one visible plane) -->
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="controls">
        <div class="row">
          <button id="startCam" class="btn primary">Start Camera</button>
          <button id="stopCam" class="btn">Stop</button>
        </div>

        <div class="row">
          <button id="detect2" class="btn">Auto-Calibrate (2 stickers)</button>
          <button id="detect3" class="btn">3-marker Homography</button>
        </div>

        <div class="row">
          <button id="autoMid" class="btn">Auto Set Midpoint</button>
          <button id="manualMid" class="btn">Manual Midpoint (tap video)</button>
        </div>

        <div class="row">
          <label class="small">Sensitivity</label>
          <input id="sensitivity" class="slider" type="range" min="0.2" max="3" step="0.05" value="1">
          <span id="sensVal" class="small">1.00</span>
        </div>

        <div class="row">
          <label class="small">Smoothing</label>
          <input id="smoothing" class="slider" type="range" min="0" max="0.99" step="0.01" value="0.6">
          <span id="smoothVal" class="small">0.60</span>
        </div>

        <div class="row">
          <button id="startRec" class="btn primary">Start Test (30s)</button>
          <button id="stopRec" class="btn">Stop</button>
        </div>

        <div class="row">
          <button id="exportCSV" class="btn">Export CSV</button>
          <button id="exportPlot" class="btn">Export Plot Image</button>
        </div>

        <div class="footer">
          Instructions (restored): Strap phone to chest/waist with rear camera facing floor. Place two small coloured stickers ~30 cm apart. (Optional: third sticker for homography). Start camera → Auto-Calibrate → Auto Set Midpoint → Start Test → Export results.
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Live Metrics & Plot</strong>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div class="metric"><div>Total sway (cm)</div><div id="totalSway" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>Sway area (cm²)</div><div id="swayArea" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>ML distance (cm)</div><div id="mlDist" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>AP distance (cm)</div><div id="apDist" style="font-size:18px;color:var(--accent)">0.000</div></div>
      </div>

      <div class="plot" style="margin-top:10px">
        <canvas id="plotCanvas" width="680" height="320"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:6px">
          <div class="small">X: ML (cm) — Right positive</div>
          <div id="timer" class="small">Timer: --</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
// Key changes in this build (engineering notes):
// - Only one video element + one overlay canvas (removes duplicate preview planes).
// - Pixel->cm conversion uses measured marker distance (30 cm reference).
// - Smoothing applied (exponential moving average) to reduce noise and jitter.
// - Sensitivity multiplier to tune plot scale (user-adjustable).
// - Automatic marker re-detection and tracking re-init on loss or large shake.
// - Restored instructions text and explicit behavior preservation.

// DOM
const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const plotCanvas = document.getElementById('plotCanvas');
const pctx = plotCanvas.getContext('2d');

const startCamBtn = document.getElementById('startCam');
const stopCamBtn = document.getElementById('stopCam');
const detect2Btn = document.getElementById('detect2');
const detect3Btn = document.getElementById('detect3');
const autoMidBtn = document.getElementById('autoMid');
const manualMidBtn = document.getElementById('manualMid');
const startRecBtn = document.getElementById('startRec');
const stopRecBtn = document.getElementById('stopRec');
const exportCSVBtn = document.getElementById('exportCSV');
const exportPlotBtn = document.getElementById('exportPlot');
const sensSlider = document.getElementById('sensitivity');
const smoothingSlider = document.getElementById('smoothing');
const sensVal = document.getElementById('sensVal');
const smoothVal = document.getElementById('smoothVal');

const totalSwayEl = document.getElementById('totalSway');
const swayAreaEl = document.getElementById('swayArea');
const mlDistEl = document.getElementById('mlDist');
const apDistEl = document.getElementById('apDist');
const timerEl = document.getElementById('timer');

let stream = null, videoReady = false;
let markers = [], thirdMarker = null;
let pixelsPerCm = null; // pixel-to-cm factor (px per cm)
let baselineMid = null; // in image px or world cm if homography
let useHomography = false, H = null;
let prevGray = null, prevPts = null, template = null;
let trackingInited = false, measuring = false;
let data = [], lastTracked = null;
let lastProcess = 0;
let lastGoodTimestamp = performance.now();

// smoothing and sensitivity
let alpha = parseFloat(smoothingSlider.value);
let sensitivity = parseFloat(sensSlider.value);
smoothingSlider.addEventListener('input', ()=>{ alpha = parseFloat(smoothingSlider.value); smoothVal.innerText = alpha.toFixed(2); });
sensSlider.addEventListener('input', ()=>{ sensitivity = parseFloat(sensSlider.value); sensVal.innerText = sensitivity.toFixed(2); });

// Ensure single preview plane sizing
function ensureSize(){
  overlay.width = video.videoWidth || video.clientWidth || 640;
  overlay.height = video.videoHeight || video.clientHeight || 480;
  plotCanvas.width = Math.min(800, Math.max(400, overlay.width));
  plotCanvas.height = 320;
}

startCamBtn.onclick = async ()=>{
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false });
    video.srcObject = stream;
    await video.play();
    await new Promise(r => {
      if (video.videoWidth && video.videoHeight) return r();
      const h = ()=>{ video.removeEventListener('loadedmetadata', h); r(); };
      video.addEventListener('loadedmetadata', h);
      setTimeout(r, 1500);
    });
    ensureSize();
    videoReady = true;
    requestAnimationFrame(loop);
  }catch(e){
    alert('Camera error: ' + e);
  }
};
stopCamBtn.onclick = ()=>{ if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; video.pause(); video.srcObject=null; videoReady=false; } };

// small capture for marker detection (reduced resolution for speed)
async function captureSmall(pw=480){
  const ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
  const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph;
  const tctx = tmp.getContext('2d'); tctx.drawImage(video, 0, 0, pw, ph);
  return tctx.getImageData(0,0,pw,ph);
}

// improved blob detection tuned for small stickers (area thresholds tightened)
async function detectBlobs(){
  const imgd = await captureSmall(480);
  const pw = imgd.width, ph = imgd.height; const d = imgd.data;
  const mask = new Uint8Array(pw*ph);
  for (let i=0,j=0;i<d.length;i+=4,j++){
    const r=d[i], g=d[i+1], b=d[i+2]; const mx=Math.max(r,g,b), mn=Math.min(r,g,b);
    const sat = mx===0?0:(mx-mn)/mx;
    // stricter threshold to find small saturated stickers, ignore large areas
    mask[j] = (sat>0.4 && mx>120)?1:0;
  }
  const visited = new Uint8Array(pw*ph); const blobs=[];
  for (let y=0;y<ph;y++){
    for (let x=0;x<pw;x++){
      const idx = y*pw + x;
      if (mask[idx] && !visited[idx]){
        let stack=[idx], sumx=0, sumy=0, c=0;
        visited[idx]=1;
        while(stack.length){
          const cur = stack.pop(); const cx = cur % pw, cy = Math.floor(cur / pw);
          sumx += cx; sumy += cy; c++;
          const n = [cur-1,cur+1,cur-pw,cur+pw];
          for (const nn of n) if (nn>=0 && nn<pw*ph && mask[nn] && !visited[nn]){ visited[nn]=1; stack.push(nn); }
        }
        // accept small clusters likely to be stickers
        if (c > 8 && c < 2000){
          blobs.push({cx: sumx/c, cy: sumy/c, c});
        }
      }
    }
  }
  // sort by closeness to center (prefer central blobs)
  const cx = pw/2, cy = ph/2;
  blobs.sort((a,b)=>Math.hypot(a.cx-cx,a.cy-cy)-Math.hypot(b.cx-cx,b.cy-cy));
  return {blobs, pw, ph};
}

// 2-marker calibration
detect2Btn.onclick = async ()=>{
  if (!videoReady){ alert('Start camera first'); return; }
  const res = await detectBlobs();
  const blobs = res.blobs;
  if (blobs.length < 2){ alert('Found ' + blobs.length + ' sticker(s). Need at least 2.'); return; }
  const b1 = blobs[0], b2 = blobs[1];
  const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
  markers = [{x: b1.cx * sx, y: b1.cy * sy}, {x: b2.cx * sx, y: b2.cy * sy}];
  // compute pixels per cm (px per cm)
  const pxDist = Math.hypot(markers[0].x - markers[1].x, markers[0].y - markers[1].y);
  pixelsPerCm = pxDist / 30.0; // user placed stickers 30 cm apart
  alert('2-marker calibration OK — px/cm=' + pixelsPerCm.toFixed(3));
};

// 3-marker homography calibration
detect3Btn.onclick = async ()=>{
  if (!videoReady){ alert('Start camera first'); return; }
  if (typeof cv === 'undefined'){ alert('OpenCV.js required for homography'); return; }
  const res = await detectBlobs();
  const blobs = res.blobs;
  if (blobs.length < 3){ alert('Found ' + blobs.length + ' sticker(s). Need at least 3.'); return; }
  const b1 = blobs[0], b2 = blobs[1], b3 = blobs[2];
  const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
  const p1 = {x: b1.cx * sx, y: b1.cy * sy}, p2 = {x: b2.cx * sx, y: b2.cy * sy}, p3 = {x: b3.cx * sx, y: b3.cy * sy};
  // define world points assume p1->(0,0), p2->(30,0), p3->(0,30) cm basis (user should place approx L-shape)
  const src = cv.matFromArray(3,1,cv.CV_32FC2, [p1.x,p1.y,p2.x,p2.y,p3.x,p3.y]);
  const dst = cv.matFromArray(3,1,cv.CV_32FC2, [0,0, 30,0, 0,30]);
  const Hmat = cv.findHomography(src, dst);
  if (!Hmat || Hmat.empty()){ alert('Homography failed'); src.delete(); dst.delete(); return; }
  H = Hmat; useHomography = true; markers = [p1,p2]; thirdMarker = p3;
  // when using homography, pixelsPerCm becomes variable; but keep px/cm from markers average in image for reference
  const pxDist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
  pixelsPerCm = pxDist / 30.0;
  alert('3-marker homography OK — px/cm=' + pixelsPerCm.toFixed(3));
  src.delete(); dst.delete();
};

// Auto set midpoint
autoMidBtn.onclick = ()=>{
  if (markers.length < 2){ alert('Calibrate first'); return; }
  const mx = (markers[0].x + markers[1].x)/2, my = (markers[0].y + markers[1].y)/2;
  baselineMid = {x: mx, y: my, unit: 'px'};
  initTracking({x: mx, y: my});
  alert('Midpoint set and tracker initialized');
};

manualMidBtn.onclick = ()=>{ alert('Tap video to set midpoint'); };
overlay.addEventListener('click', (ev)=>{
  if (!videoReady) return;
  const r = overlay.getBoundingClientRect();
  const x = (ev.clientX - r.left) * (overlay.width / r.width);
  const y = (ev.clientY - r.top) * (overlay.height / r.height);
  baselineMid = {x: x, y: y, unit: 'px'};
  initTracking({x:x,y:y});
  alert('Manual midpoint set and tracker initialized');
});

// Tracking init using LK template or initial point
function initTracking(pt){
  if (typeof cv === 'undefined'){ trackingInited=false; return; }
  const pw = 320, ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
  const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph;
  const tctx = tmp.getContext('2d'); tctx.drawImage(video,0,0,pw,ph);
  const imgd = tctx.getImageData(0,0,pw,ph);
  if (prevGray){ try{ prevGray.delete(); }catch(e){} prevGray=null; }
  prevGray = cv.matFromImageData(imgd); cv.cvtColor(prevGray, prevGray, cv.COLOR_RGBA2GRAY);
  if (prevPts){ try{ prevPts.delete(); }catch(e){} prevPts=null; }
  const procX = Math.round(pt.x * (pw / overlay.width));
  const procY = Math.round(pt.y * (ph / overlay.height));
  prevPts = new cv.Mat(1,1,cv.CV_32FC2); prevPts.data32F[0] = procX; prevPts.data32F[1] = procY;
  // template for template matching fallback
  const tsize = 41; const rx = Math.max(0, procX - Math.floor(tsize/2)), ry = Math.max(0, procY - Math.floor(tsize/2));
  const rw = Math.min(tsize, pw - rx), rh = Math.min(tsize, ph - ry);
  if (template){ try{ template.delete(); }catch(e){} template=null; }
  if (rw>4 && rh>4){ const src = cv.matFromImageData(imgd); let g = new cv.Mat(); cv.cvtColor(src,g,cv.COLOR_RGBA2GRAY); template = g.roi(new cv.Rect(rx,ry,rw,rh)).clone(); g.delete(); src.delete(); }
  trackingInited = true;
  data = [];
  lastTracked = {x: pt.x, y: pt.y, Xcm:0, Ycm:0};
}

// process frame: optical flow + fallback template matching + pixel->cm conversion + smoothing
function processFrame(){
  if (!trackingInited) return;
  if (typeof cv === 'undefined') return;
  const pw = 320, ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
  createImageBitmap(video).then(bitmap=>{
    const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph;
    const tctx = tmp.getContext('2d'); tctx.drawImage(bitmap,0,0,pw,ph); bitmap.close();
    const imgd = tctx.getImageData(0,0,pw,ph);
    let gray = cv.matFromImageData(imgd); cv.cvtColor(gray, gray, cv.COLOR_RGBA2GRAY);
    let next = new cv.Mat(), status = new cv.Mat(), err = new cv.Mat();
    try{
      cv.calcOpticalFlowPyrLK(prevGray, gray, prevPts, next, status, err, new cv.Size(21,21), 3);
    }catch(e){
      console.warn('LK error', e);
    }
    let usedX = null, usedY = null;
    if (status && status.data[0] === 1){
      const procX = next.data32F[0], procY = next.data32F[1];
      usedX = procX * (overlay.width / pw); usedY = procY * (overlay.height / ph);
    } else if (template){
      // fallback to template matching if LK fails
      let src = cv.matFromImageData(imgd); let g = new cv.Mat(); cv.cvtColor(src,g,cv.COLOR_RGBA2GRAY);
      let res = new cv.Mat(); cv.matchTemplate(g, template, res, cv.TM_CCOEFF_NORMED); let mm = cv.minMaxLoc(res);
      const procX = mm.maxLoc.x + template.cols/2, procY = mm.maxLoc.y + template.rows/2;
      usedX = procX * (overlay.width / pw); usedY = procY * (overlay.height / ph);
      res.delete(); g.delete(); src.delete();
    }

    if (usedX !== null){
      // pixel->cm
      let Xcm = 0, Ycm = 0;
      if (useHomography && H){
        const src = cv.matFromArray(1,1,cv.CV_32FC2, [usedX, usedY]); const dst = new cv.Mat();
        cv.perspectiveTransform(src, dst, H);
        Xcm = dst.data32F[0]; Ycm = dst.data32F[1];
        src.delete(); dst.delete();
      } else {
        if (!pixelsPerCm){
          // if px/cm not set, skip until calibration
          // attempt automatic re-detect of markers if missing
          attemptAutoRedetect();
          prevGray && prevGray.delete();
          prevGray = gray;
          prevPts && prevPts.delete();
          prevPts = next;
          status.delete(); err.delete();
          return;
        }
        const baseX = baselineMid ? baselineMid.x : overlay.width/2;
        const baseY = baselineMid ? baselineMid.y : overlay.height/2;
        const dx_px = usedX - baseX, dy_px = usedY - baseY;
        // invert X to map subject-right -> positive
        Xcm = -dx_px / pixelsPerCm * sensitivity;
        Ycm = dy_px / pixelsPerCm * sensitivity;
      }

      // smoothing (EMA)
      if (!lastTracked || typeof lastTracked.Xcm === 'undefined'){
        lastTracked = {x: usedX, y: usedY, Xcm: Xcm, Ycm: Ycm};
      } else {
        lastTracked.Xcm = alpha * lastTracked.Xcm + (1-alpha) * Xcm;
        lastTracked.Ycm = alpha * lastTracked.Ycm + (1-alpha) * Ycm;
        lastTracked.x = alpha * lastTracked.x + (1-alpha) * usedX;
        lastTracked.y = alpha * lastTracked.y + (1-alpha) * usedY;
      }

      const time_s = performance.now()/1000.0;
      const sway = Math.hypot(lastTracked.Xcm, lastTracked.Ycm);
      data.push({t: time_s, px_x: usedX, px_y: usedY, Xcm: lastTracked.Xcm, Ycm: lastTracked.Ycm, sway: sway});
      lastGoodTimestamp = performance.now();
    }

    if (prevGray){ try{ prevGray.delete(); }catch(e){} }
    prevGray = gray;
    if (prevPts){ try{ prevPts.delete(); }catch(e){} }
    prevPts = next;
    if (status) try{ status.delete(); }catch(e){}; if (err) try{ err.delete(); }catch(e){}
  }).catch(e=>{ console.error('processFrame error', e); });
}

// automatic re-detection when markers lost or big shake detected
function attemptAutoRedetect(){
  detectBlobs().then(res=>{
    const blobs = res.blobs;
    if (blobs.length >= 2){
      const b1 = blobs[0], b2 = blobs[1];
      const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
      const m1 = {x: b1.cx * sx, y: b1.cy * sy}, m2 = {x: b2.cx * sx, y: b2.cy * sy};
      // update markers and px/cm
      markers = [m1, m2];
      pixelsPerCm = Math.hypot(m1.x - m2.x, m1.y - m2.y) / 30.0;
      // if baseline midpoint not set, set it
      if (!baselineMid) baselineMid = {x: (m1.x + m2.x)/2, y: (m1.y + m2.y)/2, unit:'px'};
      lastGoodTimestamp = performance.now();
      console.log('Auto redetect: markers updated, px/cm=', pixelsPerCm);
    }
  }).catch(e=>{ console.warn('auto redetect failed', e); });
}

// Loop: draw video, overlays, markers and tracked point
let lastLoop = 0;
function loop(ts){
  if (videoReady){
    ensureSize();
    octx.clearRect(0,0,overlay.width,overlay.height);
    octx.drawImage(video,0,0,overlay.width,overlay.height);

    // draw markers if available
    if (markers && markers.length >= 2){
      octx.strokeStyle = 'white'; octx.lineWidth = 2;
      octx.beginPath(); octx.moveTo(markers[0].x, markers[0].y); octx.lineTo(markers[1].x, markers[1].y); octx.stroke();
      for (let i=0;i<markers.length;i++){
        octx.fillStyle = 'red'; octx.beginPath(); octx.arc(markers[i].x, markers[i].y, 10, 0, Math.PI*2); octx.fill();
        octx.fillStyle = 'white'; octx.font = '14px Arial'; octx.fillText('M'+(i+1), markers[i].x+12, markers[i].y+6);
      }
    }
    if (thirdMarker){
      octx.fillStyle = 'orange'; octx.beginPath(); octx.arc(thirdMarker.x, thirdMarker.y, 9, 0, Math.PI*2); octx.fill();
      octx.fillStyle = 'white'; octx.fillText('M3', thirdMarker.x+10, thirdMarker.y+6);
    }

    // baseline display
    if (baselineMid){
      octx.fillStyle = 'lime'; octx.beginPath(); octx.arc(baselineMid.x, baselineMid.y, 8, 0, Math.PI*2); octx.fill();
    }

    // tracked point
    if (lastTracked){
      octx.fillStyle = 'cyan'; octx.beginPath(); octx.arc(lastTracked.x, lastTracked.y, 9, 0, Math.PI*2); octx.fill();
      octx.fillStyle = 'black'; octx.font = '12px Arial'; octx.fillText('T', lastTracked.x+10, lastTracked.y+4);
    }

    // run processing at ~25 Hz
    if (ts - lastProcess > 40){
      lastProcess = ts;
      // only process when tracking is initialized
      if (trackingInited) processFrame();
      // if markers are present and excessive time since lastGoodTimestamp, attempt re-detect
      if (performance.now() - lastGoodTimestamp > 2000) attemptAutoRedetect();
      // update plot and metrics every 200 ms
      if (ts - lastLoop > 200){
        drawSpaghetti(); updateMetrics();
        lastLoop = ts;
      }
    }
  }
  requestAnimationFrame(loop);
}

// Spaghetti plot with axes and start/end markers
function drawSpaghetti(){
  pctx.clearRect(0,0,plotCanvas.width,plotCanvas.height);
  if (!data.length) return;
  const pts = data.map(d=>({x:d.Xcm, y:d.Ycm}));
  let minX = Math.min(...pts.map(p=>p.x)), maxX = Math.max(...pts.map(p=>p.x));
  let minY = Math.min(...pts.map(p=>p.y)), maxY = Math.max(...pts.map(p=>p.y));
  if (maxX - minX < 0.01){ maxX += 0.5; minX -= 0.5; }
  if (maxY - minY < 0.01){ maxY += 0.5; minY -= 0.5; }
  const rangeX = maxX - minX, rangeY = maxY - minY;
  // background grid
  pctx.fillStyle = '#ffffff'; pctx.fillRect(0,0,plotCanvas.width,plotCanvas.height);
  pctx.strokeStyle = '#eef2f7';
  for (let gx=0; gx<=10; gx++){ pctx.beginPath(); pctx.moveTo(gx*(plotCanvas.width/10),0); pctx.lineTo(gx*(plotCanvas.width/10),plotCanvas.height); pctx.stroke(); }
  for (let gy=0; gy<=8; gy++){ pctx.beginPath(); pctx.moveTo(0,gy*(plotCanvas.height/8)); pctx.lineTo(plotCanvas.width,gy*(plotCanvas.height/8)); pctx.stroke(); }
  // axes labels
  pctx.fillStyle = '#042028'; pctx.font = '12px Arial'; pctx.fillText('ML (cm)', 8, 14); pctx.fillText('AP (cm)', plotCanvas.width-48, plotCanvas.height-6);
  // path
  pctx.strokeStyle = '#e11d48'; pctx.lineWidth = 2; pctx.beginPath();
  for (let i=0;i<pts.length;i++){
    const nx = ((pts[i].x - minX)/rangeX) * plotCanvas.width;
    const ny = plotCanvas.height - ((pts[i].y - minY)/rangeY) * plotCanvas.height;
    if (i===0) pctx.moveTo(nx,ny); else pctx.lineTo(nx,ny);
  }
  pctx.stroke();
  // start/end markers
  const start = pts[0], end = pts[pts.length-1];
  const sx = ((start.x - minX)/rangeX) * plotCanvas.width, sy = plotCanvas.height - ((start.y - minY)/rangeY) * plotCanvas.height;
  const ex = ((end.x - minX)/rangeX) * plotCanvas.width, ey = plotCanvas.height - ((end.y - minY)/rangeY) * plotCanvas.height;
  pctx.fillStyle = 'green'; pctx.beginPath(); pctx.arc(sx,sy,6,0,Math.PI*2); pctx.fill(); pctx.fillStyle='black'; pctx.fillText('Start', sx+8, sy+4);
  pctx.fillStyle = 'blue'; pctx.beginPath(); pctx.arc(ex,ey,6,0,Math.PI*2); pctx.fill(); pctx.fillStyle='white'; pctx.fillText('End', ex+8, ey+4);
  // ticks
  pctx.fillStyle='#042028'; pctx.font='11px Arial';
  pctx.fillText(minX.toFixed(2), 4, plotCanvas.height-4); pctx.fillText(maxX.toFixed(2), plotCanvas.width-48, plotCanvas.height-4);
  pctx.fillText(minY.toFixed(2), 4, 14); pctx.fillText(maxY.toFixed(2), 4, plotCanvas.height-20);
}

function updateMetrics(){
  if (!data.length){ totalSwayEl.innerText='0.000'; swayAreaEl.innerText='0.000'; mlDistEl.innerText='0.000'; apDistEl.innerText='0.000'; return; }
  const xs = data.map(d=>d.Xcm), ys = data.map(d=>d.Ycm);
  let path=0; for (let i=0;i<data.length-1;i++){ path += Math.hypot(data[i+1].Xcm - data[i].Xcm, data[i+1].Ycm - data[i].Ycm); }
  const mlDist = Math.max(...xs) - Math.min(...xs);
  const apDist = Math.max(...ys) - Math.min(...ys);
  // area via convex hull
  const pts = xs.map((v,i)=>[xs[i], ys[i]]);
  const hull = convexHull(pts);
  const area = polygonArea(hull);
  totalSwayEl.innerText = path.toFixed(3);
  swayAreaEl.innerText = area.toFixed(3);
  mlDistEl.innerText = mlDist.toFixed(3);
  apDistEl.innerText = apDist.toFixed(3);
}

// convex hull & area
function convexHull(points){
  if (points.length <= 3) return points;
  points = points.map(p=>[p[0],p[1]]).sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0]);
  const cross=(o,a,b)=> (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]);
  const lower=[]; for (let p of points){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p); }
  const upper=[]; for (let i=points.length-1;i>=0;i--){ const p = points[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); }
  upper.pop(); lower.pop(); return lower.concat(upper);
}
function polygonArea(poly){ if (!poly || poly.length<3) return 0; let a=0; for (let i=0;i<poly.length;i++){ const j=(i+1)%poly.length; a += poly[i][0]*poly[j][1] - poly[j][0]*poly[i][1]; } return Math.abs(a)/2.0; }

// recording with automatic stop at duration
let testTimer = null;
startRecBtn.onclick = ()=>{
  if (!baselineMid && !pixelsPerCm){ alert('Set midpoint and calibrate markers first'); return; }
  data = []; measuring = true;
  let remaining = 30; timerEl.innerText = 'Timer: ' + remaining + 's';
  testTimer = setInterval(()=>{ remaining -= 1; timerEl.innerText = 'Timer: ' + remaining + 's'; if (remaining<=0){ clearInterval(testTimer); stopRec(); } }, 1000);
};
stopRecBtn.onclick = ()=>{ if (testTimer) clearInterval(testTimer); stopRec(); };
function stopRec(){ measuring=false; timerEl.innerText = 'Timer: --'; drawSpaghetti(); updateMetrics(); alert('Test finished'); }

// export CSV
exportCSVBtn.onclick = ()=>{
  if (!data.length){ alert('No data to export'); return; }
  let header = 'meta: px_per_cm=' + (pixelsPerCm?pixelsPerCm.toFixed(3):'NA') + '\\n';
  header += 't_s,px_x,px_y,X_cm,Y_cm,sway_cm\\n';
  const rows = data.map(d=>[d.t.toFixed(3), d.px_x.toFixed(2), d.px_y.toFixed(2), d.Xcm.toFixed(3), d.Ycm.toFixed(3), d.sway.toFixed(3)].join(',')).join('\\n');
  const csv = header + rows;
  const blob = new Blob([csv], {type:'text/csv'}); const a=document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sway_data.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1500);
};

// export plot image
exportPlotBtn.onclick = ()=>{ drawSpaghetti(); const link = document.createElement('a'); link.href = plotCanvas.toDataURL('image/png'); link.download = 'sway_plot.png'; link.click(); };

// periodic auto-redetect to keep markers updated when phone shaken
setInterval(()=>{ if (videoReady && (markers.length<2 || performance.now()-lastGoodTimestamp>3000)) attemptAutoRedetect(); }, 2000);

// video loaded
video.addEventListener('loadedmetadata', ()=>{ ensureSize(); videoReady = true; requestAnimationFrame(loop); });

// initial UI values
sensVal.innerText = sensitivity.toFixed(2);
smoothVal.innerText = alpha.toFixed(2);
</script>
</body>
</html>
