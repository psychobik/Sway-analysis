<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>SwayMed — Mobile UI Fix</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover"/>
  <style>
    :root{--accent:#0b63d8;--muted:#666;--bg:#f7f9fc}
    html,body{height:100%;margin:0;background:var(--bg);font-family:Inter, system-ui, Arial;padding:8px;color:#081426}
    .app{max-width:520px;margin:0 auto}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px;border-radius:10px;background:white;box-shadow:0 2px 6px rgba(10,20,40,0.06);margin-bottom:8px}
    header .title{font-weight:700}
    main{display:flex;flex-direction:column;gap:10px}
    .card{background:white;padding:10px;border-radius:10px;box-shadow:0 1px 3px rgba(10,20,40,0.04)}
    #videoArea{position:relative;border-radius:10px;overflow:hidden;background:#000;height:56vw;max-height:640px} /* tall box for mobile */
    video{width:100%;height:100%;object-fit:cover;display:block}
    #overlay{position:absolute;left:0;top:0;pointer-events:auto}
    .controls{display:flex;flex-direction:column;gap:10px;margin-top:6px}
    .row{display:flex;gap:8px}
    .btn{flex:1;padding:12px;border-radius:10px;border:0;background:#fff;box-shadow:0 1px 0 rgba(0,0,0,0.06);font-weight:600}
    .btn.primary{background:var(--accent);color:white}
    #plot{width:100%;height:120px;border-radius:8px;background:#fff;display:block}
    .metrics{font-size:13px;white-space:pre-wrap;margin-top:6px;color:#123}
    .small{font-size:13px;color:var(--muted)}
    footer{font-size:12px;text-align:center;color:var(--muted);margin-top:8px}
    /* make large buttons for mobile */
    .big{padding:14px;border-radius:12px;font-size:15px}
  </style>
</head>
<body>
  <div class="app">
    <header class="card">
      <div class="title">SwayMed — Mobile</div>
      <div class="small">Local | Real-time</div>
    </header>

    <main>
      <section class="card" id="cameraCard">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
          <strong>Live Camera</strong>
          <div class="small">Tap to select track</div>
        </div>
        <div id="videoArea">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>

        <div class="controls">
          <div class="row">
            <button id="startCam" class="btn primary big">Start Camera (720p min)</button>
            <button id="stopCam" class="btn big">Stop</button>
          </div>

          <div class="row">
            <button id="detectMarkers" class="btn big">Auto‑Calibrate (small stickers)</button>
          </div>

          <div class="row">
            <button id="selectTrack" class="btn big">Select Track (tap)</button>
            <button id="autoSelect" class="btn big">Auto Select (on line)</button>
          </div>

          <div class="row">
            <button id="startRec" class="btn primary big">Start Assessment</button>
            <button id="stopRec" class="btn big">Stop</button>
          </div>

          <div class="row">
            <button id="exportCSV" class="btn big">Export CSV</button>
            <button id="flipToggle" class="btn big">Flip: OFF</button>
          </div>

          <div id="stat" class="small">Status: idle</div>
        </div>
      </section>

      <section class="card">
        <strong>Live Sway Visualization</strong>
        <canvas id="plot"></canvas>
        <div id="feedback" class="small" style="margin-top:6px">No data</div>
      </section>

      <section class="card">
        <strong>Summary Metrics</strong>
        <div id="metrics" class="metrics">No data</div>
        <div class="small" style="margin-top:8px">Instructions: place two small colored stickers ~30 cm apart on the floor. Strap phone to chest with rear camera facing floor.</div>
      </section>
    </main>

    <footer>© SwayMed</footer>
  </div>

<script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvLoaded()"></script>
<script>
/* Mobile-first app: responsive layout, large video area, buttons stacked.
   All control buttons are present and wired: Auto-Calibrate, Select Track (tap), Auto Select, Start/Stop, Export CSV.
   Marker detection, auto-select, and tracking code retained from previous v4, adapted for mobile layout.
*/

const video = document.getElementById('video');
const overlay = document.getElementById('overlay');
const octx = overlay.getContext('2d');
const statEl = document.getElementById('stat');
const plot = document.getElementById('plot');
const pctx = plot.getContext('2d');
const feedback = document.getElementById('feedback');
const metricsEl = document.getElementById('metrics');
const flipBtn = document.getElementById('flipToggle');

let stream=null, videoReady=false, flipHorizontal=false;
let markers=[], pixelsPerCm=null, trackingPoint=null;
let prevGray=null, prevPts=null, template=null;
let trackingInited=false, measuring=false;
let data=[], baseline=null, lastFiltered=null;
let raf=null, lastProcess=0;
const PROCESS_INTERVAL=50, PLOT_WINDOW=150;

function setStatus(s){ statEl.innerText = 'Status: ' + s; }
function setFeedback(s){ feedback.innerText = s; }
function setMetrics(s){ metricsEl.innerText = s; }

// request camera at 720p minimum (best-effort)
async function startCamera(){
  try{
    setStatus('Requesting camera (720p min)');
    const constraints = {
      video: {
        facingMode: { ideal: 'environment' },
        width: { min: 1280, ideal: 1920 },
        height: { min: 720, ideal: 1080 },
        frameRate: { ideal: 30 }
      }, audio:false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    video.setAttribute('playsinline','');
    await video.play();
    // wait for metadata
    await new Promise(res=>{ if (video.videoWidth && video.videoHeight) return res(); const onmd=()=>{video.removeEventListener('loadedmetadata', onmd); res();}; video.addEventListener('loadedmetadata', onmd); setTimeout(res,2000); });
    // set canvas to intrinsic resolution so mapping is correct
    overlay.width = video.videoWidth || 1280;
    overlay.height = video.videoHeight || 720;
    // responsive video area height
    document.getElementById('videoArea').style.height = Math.min(window.innerHeight * 0.62, 720) + 'px';
    videoReady = true;
    setStatus('Camera started: ' + overlay.width + 'x' + overlay.height);
    // flip heuristic
    try{ const track = stream.getVideoTracks()[0]; const settings = track.getSettings ? track.getSettings() : {}; flipHorizontal = settings.facingMode === 'user'; flipBtn.innerText = 'Flip: ' + (flipHorizontal ? 'ON' : 'OFF'); }catch(e){}
    startLoop();
  }catch(e){
    console.error('startCamera error', e);
    alert('Camera error: ' + (e.message || e));
    setStatus('camera error');
  }
}

function stopCamera(){
  if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; video.pause(); video.srcObject=null; videoReady=false; setStatus('camera stopped'); if (raf) cancelAnimationFrame(raf); }
}

flipBtn.addEventListener('click', ()=>{ flipHorizontal = !flipHorizontal; flipBtn.innerText = 'Flip: ' + (flipHorizontal ? 'ON' : 'OFF'); });

function startLoop(){
  function loop(ts){
    try{
      if (videoReady){
        // draw video frame with flip mapping
        octx.save();
        if (flipHorizontal){ octx.translate(overlay.width,0); octx.scale(-1,1); octx.drawImage(video,0,0,overlay.width,overlay.height); } else { octx.setTransform(1,0,0,1,0,0); octx.drawImage(video,0,0,overlay.width,overlay.height); }
        octx.restore();
        // draw markers & tracking point
        markers.forEach((m,i)=>{ octx.beginPath(); octx.fillStyle='red'; octx.arc(m.x,m.y,6,0,2*Math.PI); octx.fill(); octx.fillStyle='white'; octx.fillText(i+1,m.x+8,m.y+4); });
        if (trackingPoint){ octx.strokeStyle='lime'; octx.lineWidth=2; octx.beginPath(); octx.arc(trackingPoint.x,trackingPoint.y,10,0,2*Math.PI); octx.stroke(); }
        if (ts - lastProcess > PROCESS_INTERVAL){ lastProcess = ts; if (trackingInited) processFrame(); if (measuring){ drawPlot(); updateFeedback(); } }
      }
    }catch(e){ console.error('loop', e); }
    raf = requestAnimationFrame(loop);
  }
  raf = requestAnimationFrame(loop);
}

/* Detect markers tuned for small stickers - maps result to overlay coords accounting for flip */
async function detectMarkers(){
  if (!videoReady){ alert('Start camera first'); return; }
  setStatus('Detecting small stickers — hold still');
  try{
    const pw = 480; const ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
    let bitmap;
    try{ bitmap = await createImageBitmap(video); }catch(e){ const tmp=document.createElement('canvas'); tmp.width=pw; tmp.height=ph; tmp.getContext('2d').drawImage(video,0,0,pw,ph); bitmap = await createImageBitmap(tmp); }
    const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph; const tctx = tmp.getContext('2d');
    if (flipHorizontal){ tctx.save(); tctx.translate(pw,0); tctx.scale(-1,1); tctx.drawImage(bitmap,0,0,pw,ph); tctx.restore(); } else { tctx.drawImage(bitmap,0,0,pw,ph); }
    bitmap.close();
    const img = tctx.getImageData(0,0,pw,ph); const dataArr = img.data; const mask = new Uint8Array(pw*ph);
    for (let i=0,j=0;i<dataArr.length;i+=4,j++){ const r=dataArr[i], g=dataArr[i+1], b=dataArr[i+2]; const mx=Math.max(r,g,b), mn=Math.min(r,g,b); const sat = mx===0?0:(mx-mn)/mx; mask[j] = (sat>0.4 && mx>100)?1:0; }
    const visited = new Uint8Array(pw*ph); const blobs=[]; const stack=[]; const MIN_BLOB=20; const MAX_BLOB=3000;
    for (let y=0;y<ph;y++){ for (let x=0;x<pw;x++){ const idx=y*pw+x; if (mask[idx] && !visited[idx]){ let sumx=0,sumy=0,count=0; stack.push(idx); visited[idx]=1; while(stack.length){ const cur=stack.pop(); const cx=cur%pw, cy=Math.floor(cur/pw); count++; sumx+=cx; sumy+=cy; const nlist=[cur-1,cur+1,cur-pw,cur+pw]; for (const n of nlist) if(n>=0 && n<pw*ph && mask[n] && !visited[n]){ visited[n]=1; stack.push(n); } } if (count>=MIN_BLOB && count<=MAX_BLOB) blobs.push({count, cx: sumx/count, cy: sumy/count}); } } }
    if (blobs.length<2){ setStatus('Markers not found'); alert('Found ' + blobs.length + ' small color blob(s). Ensure two stickers visible.'); markers=[]; return; }
    const centerX = pw/2, centerY = ph/2; blobs.sort((a,b)=>Math.hypot(a.cx-centerX,a.cy-centerY) - Math.hypot(b.cx-centerX,b.cy-centerY));
    const b1=blobs[0], b2=blobs[1]; const scaleX = overlay.width/pw, scaleY = overlay.height/ph; const mapX = x => flipHorizontal ? overlay.width - x*scaleX : x*scaleX;
    markers = [{x: mapX(b1.cx), y: b1.cy*scaleY, area: b1.count}, {x: mapX(b2.cx), y: b2.cy*scaleY, area: b2.count}];
    const dx = markers[0].x - markers[1].x, dy = markers[0].y - markers[1].y; const px = Math.hypot(dx,dy); pixelsPerCm = px/30.0;
    setStatus('Markers detected. px/cm=' + pixelsPerCm.toFixed(3));
    alert('Calibration complete: ' + px.toFixed(1) + ' px = 30 cm');
  }catch(err){ console.error('detectMarkers', err); setStatus('marker detect failed'); alert('Marker detection error: ' + (err.message||err)); }
}

/* Auto-select projects center onto line and clamps to segment (as requested) */
function autoSelectTrack(){
  if (markers.length<2){ alert('Detect markers first'); return; }
  const A = markers[0], B = markers[1]; const cx = overlay.width/2, cy = overlay.height/2; const ABx = B.x - A.x, ABy = B.y - A.y; const ACx = cx - A.x, ACy = cy - A.y; const denom = ABx*ABx + ABy*ABy; let t = denom>0 ? (ACx*ABx + ACy*ABy)/denom : 0; t = Math.max(0, Math.min(1, t)); let px = A.x + t*ABx, py = A.y + t*ABy; if (t<=0.001){ px = A.x; py = A.y; } if (t>=0.999){ px = B.x; py = B.y; } trackingPoint = {x: px, y: py}; initTracking(trackingPoint); setStatus('Tracking point auto-selected'); alert('Tracking point set on line between stickers'); }

/* Manual select by tapping video */
function enableManualSelect(){ if(!videoReady){ alert('Start camera first'); return; } setStatus('Tap video to select'); const handler=(ev)=>{ const r=overlay.getBoundingClientRect(); const x=(ev.clientX-r.left)*(overlay.width/r.width); const y=(ev.clientY-r.top)*(overlay.height/r.height); trackingPoint={x,y}; initTracking(trackingPoint); overlay.removeEventListener('click',handler); setStatus('Tracking point set'); alert('Tracking point set'); }; overlay.addEventListener('click', handler); }

/* initTracking: creates template respecting flip */
function initTracking(pt){
  if (typeof cv === 'undefined'){ alert('OpenCV not loaded; tracking requires OpenCV'); return; }
  const pw = 320; const ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
  const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph; const tctx = tmp.getContext('2d');
  if (flipHorizontal){ tctx.save(); tctx.translate(pw,0); tctx.scale(-1,1); tctx.drawImage(video,0,0,pw,ph); tctx.restore(); } else { tctx.drawImage(video,0,0,pw,ph); }
  const imgd = tctx.getImageData(0,0,pw,ph);
  if (prevGray){ try{ prevGray.delete(); }catch(e){} prevGray=null; }
  prevGray = cv.matFromImageData(imgd); cv.cvtColor(prevGray, prevGray, cv.COLOR_RGBA2GRAY);
  if (prevPts){ try{ prevPts.delete(); }catch(e){} prevPts=null; }
  prevPts = new cv.Mat(1,1,cv.CV_32FC2); prevPts.data32F[0] = pt.x; prevPts.data32F[1] = pt.y;
  const px = Math.round(pt.x * (pw / overlay.width)), py = Math.round(pt.y * (ph / overlay.height));
  const tsize = 41; const rx = Math.max(0, px - Math.floor(tsize/2)), ry = Math.max(0, py - Math.floor(tsize/2));
  const rw = Math.min(tsize, pw - rx), rh = Math.min(tsize, ph - ry);
  if (template){ try{ template.delete(); }catch(e){} template=null; }
  if (rw>4 && rh>4){ const src = cv.matFromImageData(imgd); let grayFull = new cv.Mat(); cv.cvtColor(src, grayFull, cv.COLOR_RGBA2GRAY); template = grayFull.roi(new cv.Rect(rx, ry, rw, rh)).clone(); grayFull.delete(); src.delete(); }
  trackingInited = true; data=[]; baseline=null; lastFiltered=null; setStatus('Tracking initialized'); alert('Tracking initialized'); 
}

/* processFrame (LK + template fallback) */
function processFrame(){
  if (!trackingInited) return;
  try{
    const pw = 320; const ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
    createImageBitmap(video).then(bitmap=>{
      const tmp = document.createElement('canvas'); tmp.width = pw; tmp.height = ph; const tctx = tmp.getContext('2d');
      if (flipHorizontal){ tctx.save(); tctx.translate(pw,0); tctx.scale(-1,1); tctx.drawImage(bitmap,0,0,pw,ph); tctx.restore(); } else { tctx.drawImage(bitmap,0,0,pw,ph); }
      bitmap.close();
      const imgd = tctx.getImageData(0,0,pw,ph);
      let gray = cv.matFromImageData(imgd); cv.cvtColor(gray, gray, cv.COLOR_RGBA2GRAY);
      let next = new cv.Mat(), status = new cv.Mat(), err = new cv.Mat();
      try{ cv.calcOpticalFlowPyrLK(prevGray, gray, prevPts, next, status, err, new cv.Size(21,21), 3, new cv.TermCriteria(cv.TermCriteria_EPS|cv.TermCriteria_COUNT, 20, 0.03)); }catch(e){}
      let usedX=null, usedY=null;
      if (status && status.data[0]===1){ usedX = next.data32F[0]; usedY = next.data32F[1]; }
      else if (template){
        let src = cv.matFromImageData(imgd); let grayFull = new cv.Mat(); cv.cvtColor(src, grayFull, cv.COLOR_RGBA2GRAY);
        let res = new cv.Mat(); cv.matchTemplate(grayFull, template, res, cv.TM_CCOEFF_NORMED); let mm = cv.minMaxLoc(res);
        usedX = mm.maxLoc.x * (overlay.width / pw) + template.cols/2 * (overlay.width / pw);
        usedY = mm.maxLoc.y * (overlay.height / ph) + template.rows/2 * (overlay.height / ph);
        res.delete(); grayFull.delete(); src.delete();
      }
      if (usedX !== null){
        const t = performance.now()/1000.0; const X_cm = usedX / pixelsPerCm; const Y_cm = usedY / pixelsPerCm;
        if (!baseline) baseline = {X_cm, Y_cm, t};
        const dx = X_cm - baseline.X_cm, dy = Y_cm - baseline.Y_cm;
        let sway = Math.hypot(dx, dy);
        const medianN=5, alpha=0.25;
        data.push({t, x_px: usedX, y_px: usedY, X_cm, Y_cm, sway});
        const slice = data.slice(Math.max(0, data.length - medianN)).map(d=>d.sway).sort((a,b)=>a-b); const med = slice[Math.floor(slice.length/2)];
        const filtered = lastFiltered===null?med:(alpha*med + (1-alpha)*lastFiltered);
        lastFiltered = filtered; data[data.length-1].sway_filtered = filtered;
      }
      if (prevGray){ try{ prevGray.delete(); }catch(e){} } prevGray = gray; if (prevPts){ try{ prevPts.delete(); }catch(e){} } prevPts = next; if (status) try{ status.delete(); }catch(e){}; if (err) try{ err.delete(); }catch(e){};
    }).catch(e=>{ console.error('createImageBitmap/process error', e); });
  }catch(e){ console.error('processFrame outer', e); }
}

/* Plot and feedback */
function drawPlot(){ pctx.clearRect(0,0,plot.width,plot.height); pctx.strokeStyle='#1a73e8'; pctx.lineWidth=2; const L = Math.min(data.length, PLOT_WINDOW); if (L<2) return; const arr = data.slice(-L).map(d=> d.sway_filtered !== undefined ? d.sway_filtered : d.sway); const maxV = Math.max(...arr) || 1; pctx.beginPath(); for (let i=0;i<L;i++){ const x = (i/(PLOT_WINDOW-1))*plot.width; const y = plot.height - (arr[i]/maxV)*plot.height; if (i===0) pctx.moveTo(x,y); else pctx.lineTo(x,y); } pctx.stroke(); }
function updateFeedback(){ if (!data.length){ setFeedback('No data'); setMetrics('No data'); return; } const arr = data.map(d=> d.sway_filtered !== undefined ? d.sway_filtered : d.sway); const rms = Math.sqrt(arr.reduce((s,v)=>s+v*v,0)/arr.length); const peak = Math.max(...arr); setFeedback(`RMS: ${rms.toFixed(3)} cm · Peak: ${peak.toFixed(3)} cm`); setMetrics(`Samples: ${data.length}\nDuration: ${(data[data.length-1].t - data[0].t).toFixed(2)} s\nRMS: ${rms.toFixed(3)} cm\nPeak: ${peak.toFixed(3)} cm`); }

/* CSV export */
function exportCSV(){ if (!data.length){ alert('No data recorded'); return; } let csv = "time_s,x_px,y_px,X_cm,Y_cm,sway_cm\n" + data.map(d=> [d.t.toFixed(3), d.x_px.toFixed(2), d.y_px.toFixed(2), d.X_cm.toFixed(3), d.Y_cm.toFixed(3), (d.sway_filtered!==undefined?d.sway_filtered:d.sway).toFixed(3)].join(',')).join('\n'); const blob = new Blob([csv], {type:'text/csv'}); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'sway_timeseries.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href), 1500); }

/* wiring */
document.getElementById('startCam').addEventListener('click', startCamera);
document.getElementById('stopCam').addEventListener('click', stopCamera);
document.getElementById('detectMarkers').addEventListener('click', detectMarkers);
document.getElementById('autoSelect').addEventListener('click', autoSelectTrack);
document.getElementById('selectTrack').addEventListener('click', enableManualSelect);
document.getElementById('startRec').addEventListener('click', ()=>{ if(!trackingInited){ alert('Select tracking point first'); return; } measuring=true; data=[]; baseline=null; lastFiltered=null; setStatus('recording'); });
document.getElementById('stopRec').addEventListener('click', ()=>{ measuring=false; setStatus('stopped'); exportCSV(); });
document.getElementById('exportCSV').addEventListener('click', exportCSV);

function onOpenCvLoaded(){ console.log('OpenCV loaded'); setStatus('OpenCV loaded'); }
setTimeout(()=>{ if (typeof cv === 'undefined') setStatus('OpenCV not loaded; tracking disabled until loaded.'); }, 3000);

</script>
</body>
</html>
