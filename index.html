<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<title>SwayMed — Live continuous plot (centered axes)</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
:root{--accent:#5b6cff;--muted:#6b7280}
body{font-family:Arial, Helvetica, sans-serif;background:#f4f8ff;margin:0;color:#042028}
.container{max-width:980px;margin:12px auto;padding:12px}
.header{display:flex;align-items:center;gap:12px;padding:12px}
.logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),#7c4dff);color:white;display:flex;align-items:center;justify-content:center;font-weight:700}
.grid{display:grid;grid-template-columns:380px 1fr;gap:12px}
.card{background:#fff;padding:12px;border-radius:10px;box-shadow:0 6px 18px rgba(12,30,50,0.06)}
#videoArea{position:relative;border-radius:8px;overflow:hidden;background:#000;height:420px}
video, canvas{width:100%;height:100%;display:block;object-fit:cover}
.controls{display:flex;flex-direction:column;gap:8px;margin-top:8px}
.row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.btn{padding:10px 12px;border-radius:8px;border:0;cursor:pointer;font-weight:700}
.primary{background:linear-gradient(90deg,var(--accent),#7c4dff);color:white}
.small{font-size:13px;color:#58606a}
.metric{padding:8px;background:#fbfdff;border-radius:8px;text-align:center}
.plot{background:#fff;border-radius:8px;padding:8px}
.footer{font-size:13px;color:#6b7280;margin-top:8px}
.slider{width:140px}
</style>
</head>
<body>
<div class="container">
  <div class="header"><div class="logo">S</div><div><strong>SwayMed — Centered Live Plot</strong><div class="small">Continuous live plotting; test-buffer exported only</div></div></div>

  <div class="grid">
    <div class="card">
      <strong>Live Camera & Controls</strong>
      <div id="videoArea" style="margin-top:8px">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
      </div>

      <div class="controls">
        <div class="row">
          <button id="startCam" class="btn primary">Start Camera</button>
          <button id="stopCam" class="btn">Stop</button>
        </div>

        <div class="row">
          <button id="detect2" class="btn">Auto-Calibrate (2 stickers)</button>
          <button id="detect3" class="btn">3-marker Homography</button>
        </div>

        <div class="row">
          <button id="autoMid" class="btn">Auto Set Midpoint</button>
          <!-- MANUAL MIDPOINT REMOVED per request -->
        </div>

        <div class="row">
          <label class="small">Sensitivity</label>
          <input id="sensitivity" class="slider" type="range" min="0.2" max="3" step="0.05" value="1">
          <span id="sensVal" class="small">1.00</span>
          <label class="small" style="margin-left:8px">Smoothing</label>
          <input id="smoothing" class="slider" type="range" min="0" max="0.99" step="0.01" value="0.6">
          <span id="smoothVal" class="small">0.60</span>
        </div>

        <div class="row">
          <button id="startRec" class="btn primary">Start Test (30s)</button>
          <button id="stopRec" class="btn">Stop</button>
        </div>

        <div class="row">
          <button id="exportCSV" class="btn">Export CSV (last test)</button>
          <button id="exportPlot" class="btn">Export Plot Image (last test)</button>
        </div>

        <div class="footer">
          Instructions: Strap phone to chest/waist with rear camera facing floor. Place two small coloured stickers ~30 cm apart (optional third sticker). Start camera → Auto-Calibrate → Auto Set Midpoint → Start Test → Export results.
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Live Metrics & Plot</strong>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div class="metric"><div>Total sway (cm)</div><div id="totalSway" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>Sway area (cm²)</div><div id="swayArea" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>ML distance (cm)</div><div id="mlDist" style="font-size:18px;color:var(--accent)">0.000</div></div>
        <div class="metric"><div>AP distance (cm)</div><div id="apDist" style="font-size:18px;color:var(--accent)">0.000</div></div>
      </div>

      <div class="plot" style="margin-top:10px">
        <canvas id="plotCanvas" width="680" height="680" style="width:100%;height:auto"></canvas>
        <div style="display:flex;justify-content:space-between;margin-top:6px">
          <div class="small">ML COP (cm) → (right positive)</div>
          <div id="timer" class="small">Timer: --</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script async src="https://docs.opencv.org/4.x/opencv.js"></script>
<script>
/*
  Key behavior:
  - Live data buffer (liveData) collects samples continuously from camera start.
  - testData collects fresh samples only when a test is running (Start Test resets testData).
  - Export CSV/Plot export the most recent testData (not the liveData).
  - Spaghetti plot draws liveData continuously (centered axes, dotted grid) to match provided sample.
  - Manual midpoint button removed.
*/

// DOM
const video = document.getElementById('video'), overlay = document.getElementById('overlay'), octx = overlay.getContext('2d');
const plotCanvas = document.getElementById('plotCanvas'), pctx = plotCanvas.getContext('2d');

const startCamBtn = document.getElementById('startCam'), stopCamBtn = document.getElementById('stopCam');
const detect2Btn = document.getElementById('detect2'), detect3Btn = document.getElementById('detect3');
const autoMidBtn = document.getElementById('autoMid');
const startRecBtn = document.getElementById('startRec'), stopRecBtn = document.getElementById('stopRec');
const exportCSVBtn = document.getElementById('exportCSV'), exportPlotBtn = document.getElementById('exportPlot');

const sensSlider = document.getElementById('sensitivity'), smoothingSlider = document.getElementById('smoothing');
const sensVal = document.getElementById('sensVal'), smoothVal = document.getElementById('smoothVal');

const totalSwayEl = document.getElementById('totalSway'), swayAreaEl = document.getElementById('swayArea');
const mlDistEl = document.getElementById('mlDist'), apDistEl = document.getElementById('apDist');
const timerEl = document.getElementById('timer');

let stream=null, videoReady=false;
let markers=[], thirdMarker=null;
let pixelsPerCm=null, baselineMid=null;
let useHomography=false, H=null;
let prevGray=null, prevPts=null, template=null;
let trackingInited=false;
let liveData=[];            // continuous samples since camera start (used for live plot)
let testData=[];            // fresh buffer cleared at test start, exported after test
let measuring=false;
let lastTracked=null;
let lastProcess=0, lastLoop=0, lastGoodTimestamp=performance.now();

let alpha = parseFloat(smoothingSlider.value), sensitivity = parseFloat(sensSlider.value);
smoothingSlider.addEventListener('input', ()=>{ alpha = parseFloat(smoothingSlider.value); smoothVal.innerText = alpha.toFixed(2); });
sensSlider.addEventListener('input', ()=>{ sensitivity = parseFloat(sensSlider.value); sensVal.innerText = sensitivity.toFixed(2); });

function ensureOverlaySize(){
  overlay.width = video.videoWidth || video.clientWidth || 640;
  overlay.height = video.videoHeight || video.clientHeight || 480;
  // make plotCanvas large and square for axis symmetry; keep internal px high for clarity
  plotCanvas.width = Math.max(480, overlay.width);
  plotCanvas.height = Math.max(480, overlay.width); // square to make axis symmetric visually
}

// Camera
startCamBtn.onclick = async ()=>{
  try{
    stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { ideal: 'environment' }, width:{ ideal:1280 }, height:{ ideal:720 } }, audio:false});
    video.srcObject = stream; await video.play();
    await new Promise(r=>{ if (video.videoWidth && video.videoHeight) return r(); const h=()=>{video.removeEventListener('loadedmetadata',h); r()}; video.addEventListener('loadedmetadata',h); setTimeout(r,1200); });
    ensureOverlaySize(); videoReady=true; requestAnimationFrame(loop);
  }catch(e){ alert('Camera error: '+e.message); }
};
stopCamBtn.onclick = ()=>{ if (stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; video.pause(); video.srcObject=null; videoReady=false; } };

// Small capture for detection
async function captureSmall(pw=480){
  const ph = Math.max(80, Math.round(pw * (video.videoHeight / video.videoWidth || 0.75)));
  const tmp = document.createElement('canvas'); tmp.width=pw; tmp.height=ph; const tctx = tmp.getContext('2d'); tctx.drawImage(video,0,0,pw,ph);
  return tctx.getImageData(0,0,pw,ph);
}

// Blob detection tuned for small stickers
async function detectBlobs(){
  const imgd = await captureSmall(480); const pw = imgd.width, ph = imgd.height; const d = imgd.data;
  const mask = new Uint8Array(pw*ph);
  for(let i=0,j=0;i<d.length;i+=4,j++){
    const r=d[i], g=d[i+1], b=d[i+2]; const mx=Math.max(r,g,b), mn=Math.min(r,g,b); const sat = mx===0?0:(mx-mn)/mx;
    mask[j] = (sat>0.38 && mx>110)?1:0;
  }
  const visited = new Uint8Array(pw*ph); const blobs=[];
  for (let y=0;y<ph;y++){
    for (let x=0;x<pw;x++){
      const idx = y*pw + x; if (mask[idx] && !visited[idx]){
        let stack=[idx], sumx=0,sumy=0,c=0; visited[idx]=1;
        while(stack.length){
          const cur = stack.pop(); const cx = cur % pw, cy = Math.floor(cur/pw);
          sumx += cx; sumy += cy; c++; const n=[cur-1,cur+1,cur-pw,cur+pw];
          for (const nn of n) if (nn>=0 && nn<pw*ph && mask[nn] && !visited[nn]){ visited[nn]=1; stack.push(nn); }
        }
        if (c>8 && c < 2000) blobs.push({cx: sumx/c, cy: sumy/c, c});
      }
    }
  }
  // prefer central blobs
  const cx=pw/2, cy=ph/2; blobs.sort((a,b)=>Math.hypot(a.cx-cx,a.cy-cy)-Math.hypot(b.cx-cx,b.cy-cy));
  return {blobs,pw,ph};
}

// 2-marker calibration: compute pixelsPerCm (px/cm)
detect2Btn.onclick = async ()=>{
  if (!videoReady){ alert('Start camera'); return; }
  const res = await detectBlobs(); const blobs = res.blobs;
  if (blobs.length < 2){ alert('Found '+blobs.length+' stickers. Need >=2'); return; }
  const b1=blobs[0], b2=blobs[1]; const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
  markers = [{x: b1.cx * sx, y: b1.cy * sy},{x: b2.cx * sx, y: b2.cy * sy}];
  const pxDist = Math.hypot(markers[0].x-markers[1].x, markers[0].y-markers[1].y);
  pixelsPerCm = pxDist / 30.0; // user places stickers ~30 cm apart
  lastGoodTimestamp = performance.now();
  alert('2-marker calibration OK — px/cm=' + pixelsPerCm.toFixed(3));
};

// 3-marker homography (optional)
detect3Btn.onclick = async ()=>{
  if (!videoReady){ alert('Start camera'); return; }
  if (typeof cv === 'undefined'){ alert('OpenCV.js required'); return; }
  const res = await detectBlobs(); const blobs = res.blobs;
  if (blobs.length < 3){ alert('Found '+blobs.length+' stickers. Need >=3'); return; }
  const b1=blobs[0], b2=blobs[1], b3=blobs[2]; const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
  const p1={x:b1.cx*sx,y:b1.cy*sy}, p2={x:b2.cx*sx,y:b2.cy*sy}, p3={x:b3.cx*sx,y:b3.cy*sy};
  const src = cv.matFromArray(3,1,cv.CV_32FC2,[p1.x,p1.y,p2.x,p2.y,p3.x,p3.y]);
  const dst = cv.matFromArray(3,1,cv.CV_32FC2,[0,0,30,0,0,30]);
  const Hmat = cv.findHomography(src,dst);
  if (!Hmat || Hmat.empty()){ alert('Homography failed'); src.delete(); dst.delete(); return; }
  H=Hmat; useHomography=true; markers=[p1,p2]; thirdMarker=p3;
  pixelsPerCm = Math.hypot(p1.x-p2.x,p1.y-p2.y)/30.0;
  src.delete(); dst.delete(); lastGoodTimestamp = performance.now();
  alert('3-marker homography OK — px/cm=' + pixelsPerCm.toFixed(3));
};

// Auto midpoint and initialize tracker
autoMidBtn.onclick = ()=>{
  if (markers.length < 2){ alert('Calibrate first'); return; }
  const mx = (markers[0].x + markers[1].x)/2, my = (markers[0].y + markers[1].y)/2;
  baselineMid = {x: mx, y: my, unit:'px'}; initTracking({x:mx,y:my}); alert('Midpoint set & tracker inited');
};

// init tracking using LK + template (same approach as earlier builds)
function initTracking(pt){
  if (typeof cv === 'undefined'){ trackingInited=false; return; }
  const pw = 320, ph = Math.max(80, Math.round(pw*(video.videoHeight/video.videoWidth||0.75)));
  const tmp = document.createElement('canvas'); tmp.width=pw; tmp.height=ph; const tctx = tmp.getContext('2d');
  tctx.drawImage(video,0,0,pw,ph); const imgd = tctx.getImageData(0,0,pw,ph);
  if (prevGray){ try{ prevGray.delete(); }catch(e){} prevGray=null; }
  prevGray = cv.matFromImageData(imgd); cv.cvtColor(prevGray, prevGray, cv.COLOR_RGBA2GRAY);
  if (prevPts){ try{ prevPts.delete(); }catch(e){} prevPts=null; }
  const procX = Math.round(pt.x*(pw/overlay.width)), procY = Math.round(pt.y*(ph/overlay.height));
  prevPts = new cv.Mat(1,1,cv.CV_32FC2); prevPts.data32F[0]=procX; prevPts.data32F[1]=procY;
  const tsize=41, rx=Math.max(0,procX-Math.floor(tsize/2)), ry=Math.max(0,procY-Math.floor(tsize/2));
  const rw = Math.min(tsize,pw-rx), rh = Math.min(tsize,ph-ry);
  if (template){ try{ template.delete(); }catch(e){} template=null; }
  if (rw>4 && rh>4){ const src = cv.matFromImageData(imgd); let g=new cv.Mat(); cv.cvtColor(src,g,cv.COLOR_RGBA2GRAY); template = g.roi(new cv.Rect(rx,ry,rw,rh)).clone(); g.delete(); src.delete(); }
  trackingInited=true; lastTracked = {x:pt.x,y:pt.y,Xcm:0,Ycm:0};
  // Note: liveData continues collecting from camera start; testData will be reset when test starts
}

// process frame: LK + template fallback + convert to cm + smoothing; always append to liveData; append to testData when measuring==true
function processFrame(){
  if (!trackingInited) return; if (typeof cv === 'undefined') return;
  const pw = 320, ph = Math.max(80, Math.round(pw*(video.videoHeight/video.videoWidth||0.75)));
  createImageBitmap(video).then(bitmap=>{
    const tmp = document.createElement('canvas'); tmp.width=pw; tmp.height=ph; const tctx = tmp.getContext('2d'); tctx.drawImage(bitmap,0,0,pw,ph); bitmap.close();
    const imgd = tctx.getImageData(0,0,pw,ph); let gray = cv.matFromImageData(imgd); cv.cvtColor(gray, gray, cv.COLOR_RGBA2GRAY);
    let next = new cv.Mat(), status = new cv.Mat(), err = new cv.Mat();
    try{ cv.calcOpticalFlowPyrLK(prevGray, gray, prevPts, next, status, err, new cv.Size(21,21), 3); }catch(e){ console.warn('LK',e); }
    let usedX=null, usedY=null;
    if (status && status.data[0]===1){
      const procX = next.data32F[0], procY = next.data32F[1];
      usedX = procX * (overlay.width / pw); usedY = procY * (overlay.height / ph);
    } else if (template){
      let src = cv.matFromImageData(imgd); let g=new cv.Mat(); cv.cvtColor(src,g,cv.COLOR_RGBA2GRAY);
      let res = new cv.Mat(); cv.matchTemplate(g, template, res, cv.TM_CCOEFF_NORMED); let mm = cv.minMaxLoc(res);
      const procX = mm.maxLoc.x + template.cols/2, procY = mm.maxLoc.y + template.rows/2;
      usedX = procX * (overlay.width / pw); usedY = procY * (overlay.height / ph);
      res.delete(); g.delete(); src.delete();
    }

    if (usedX !== null){
      let Xcm=0, Ycm=0;
      if (useHomography && H){
        const src = cv.matFromArray(1,1,cv.CV_32FC2,[usedX,usedY]); const dst = new cv.Mat(); cv.perspectiveTransform(src,dst,H);
        Xcm = dst.data32F[0]; Ycm = dst.data32F[1]; src.delete(); dst.delete();
      } else {
        if (!pixelsPerCm){
          attemptAutoRedetect();
        } else {
          const baseX = baselineMid ? baselineMid.x : overlay.width/2;
          const baseY = baselineMid ? baselineMid.y : overlay.height/2;
          const dx_px = usedX - baseX, dy_px = usedY - baseY;
          Xcm = -dx_px / pixelsPerCm * sensitivity;
          Ycm = dy_px / pixelsPerCm * sensitivity;
        }
      }

      // EMA smoothing
      if (!lastTracked || typeof lastTracked.Xcm==='undefined'){
        lastTracked = {x:usedX,y:usedY,Xcm:Xcm,Ycm:Ycm};
      } else {
        lastTracked.Xcm = alpha * lastTracked.Xcm + (1-alpha) * Xcm;
        lastTracked.Ycm = alpha * lastTracked.Ycm + (1-alpha) * Ycm;
        lastTracked.x = alpha * lastTracked.x + (1-alpha) * usedX;
        lastTracked.y = alpha * lastTracked.y + (1-alpha) * usedY;
      }

      const t = performance.now()/1000.0;
      const sway = Math.hypot(lastTracked.Xcm, lastTracked.Ycm);
      // ALWAYS push to liveData (continuous)
      liveData.push({t:t, px_x:usedX, px_y:usedY, Xcm:lastTracked.Xcm, Ycm:lastTracked.Ycm, sway:sway});
      // If measuring, also push to testData (fresh buffer)
      if (measuring) testData.push({t:t, px_x:usedX, px_y:usedY, Xcm:lastTracked.Xcm, Ycm:lastTracked.Ycm, sway:sway});
      lastGoodTimestamp = performance.now();
    }

    if (prevGray){ try{ prevGray.delete(); }catch(e){} }
    prevGray = gray;
    if (prevPts){ try{ prevPts.delete(); }catch(e){} }
    prevPts = next;
    try{ status.delete(); }catch(e){} try{ err.delete(); }catch(e){}
  }).catch(e=>console.error('proc error',e));
}

// Auto redetect markers in background
function attemptAutoReddetect_internal(){
  detectBlobs().then(res=>{
    const blobs = res.blobs;
    if (blobs.length>=2){
      const b1=blobs[0], b2=blobs[1]; const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
      markers = [{x:b1.cx*sx,y:b1.cy*sy},{x:b2.cx*sx,y:b2.cy*sy}];
      pixelsPerCm = Math.hypot(markers[0].x-markers[1].x, markers[0].y-markers[1].y)/30.0;
      if (!baselineMid) baselineMid = {x:(markers[0].x+markers[1].x)/2, y:(markers[0].y+markers[1].y)/2, unit:'px'};
      lastGoodTimestamp = performance.now();
      console.log('Auto redetect px/cm=',pixelsPerCm);
    }
  }).catch(e=>console.warn('auto redetect',e));
}
function attemptAutoRedetect(){ attemptAutoReddetect_internal(); }

// Loop: draw video, overlays, and run processFrame at ~25Hz; plot liveData continuously
let lastFrame = 0;
function loop(ts){
  if (videoReady){
    ensureOverlaySize();
    octx.clearRect(0,0,overlay.width,overlay.height);
    octx.drawImage(video,0,0,overlay.width,overlay.height);

    // draw red markers
    if (markers && markers.length>=2){
      octx.strokeStyle='white'; octx.lineWidth=2;
      octx.beginPath(); octx.moveTo(markers[0].x,markers[0].y); octx.lineTo(markers[1].x,markers[1].y); octx.stroke();
      for (let i=0;i<markers.length;i++){ octx.fillStyle='red'; octx.beginPath(); octx.arc(markers[i].x,markers[i].y,10,0,Math.PI*2); octx.fill(); octx.fillStyle='white'; octx.font='14px Arial'; octx.fillText('M'+(i+1), markers[i].x+12, markers[i].y+6); }
    }
    if (thirdMarker){ octx.fillStyle='orange'; octx.beginPath(); octx.arc(thirdMarker.x, thirdMarker.y,9,0,Math.PI*2); octx.fill(); octx.fillStyle='white'; octx.fillText('M3', thirdMarker.x+10, thirdMarker.y+6); }

    // baseline midpoint (lime)
    if (baselineMid){ octx.fillStyle='lime'; octx.beginPath(); octx.arc(baselineMid.x, baselineMid.y,8,0,Math.PI*2); octx.fill(); }

    // tracked point (green)
    if (lastTracked){ octx.fillStyle='limegreen'; octx.beginPath(); octx.arc(lastTracked.x, lastTracked.y,9,0,Math.PI*2); octx.fill(); octx.fillStyle='black'; octx.font='12px Arial'; octx.fillText('T', lastTracked.x+10, lastTracked.y+4); }

    // process frames at ~25Hz
    if (ts - lastProcess > 40){ lastProcess = ts; if (trackingInited) processFrame(); if (performance.now()-lastGoodTimestamp>2000) attemptAutoRedetect(); }

    // draw ongoing live plot frequently (continuous)
    if (ts - lastLoop > 150){ drawLiveSpaghetti(); updateLiveMetricsDisplay(); lastLoop = ts; }
  }
  requestAnimationFrame(loop);
}

// DRAW LIVE SPAGHETTI PLOT centered at zero with dotted grid — uses liveData (continuous)
function drawLiveSpaghetti(){
  pctx.clearRect(0,0,plotCanvas.width,plotCanvas.height);
  // need at least 2 points to draw
  if (liveData.length < 2) {
    // draw axes and dotted grid only
    drawCenteredAxes([], true);
    return;
  }
  // use last N points for live visualization to avoid over-scaling; but center axes around 0
  const pts = liveData.map(d=>({x:d.Xcm, y:d.Ycm}));
  drawCenteredAxes(pts, false);
  // draw path
  pctx.strokeStyle = '#000'; pctx.lineWidth = 1.6;
  pctx.beginPath();
  const [toCanvasX,toCanvasY,scale,offset] = worldToCanvasTransform(pts);
  for (let i=0;i<pts.length;i++){
    const nx = toCanvasX(pts[i].x), ny = toCanvasY(pts[i].y);
    if (i===0) pctx.moveTo(nx,ny); else pctx.lineTo(nx,ny);
  }
  pctx.stroke();
  // start/end markers (on last recorded testData if testData non-empty else live start/end)
  if (testData.length>0){
    // highlight start of current test in green, end in blue (if measuring ended)
    const s = testData[0], e = testData[testData.length-1];
    pctx.fillStyle='green'; pctx.beginPath(); pctx.arc(toCanvasX(s.Xcm), toCanvasY(s.Ycm),6,0,Math.PI*2); pctx.fill();
    pctx.fillStyle='blue'; pctx.beginPath(); pctx.arc(toCanvasX(e.Xcm), toCanvasY(e.Ycm),6,0,Math.PI*2); pctx.fill();
  } else {
    // if no testData yet, mark start as first live point
    const s = liveData[0], e = liveData[liveData.length-1];
    pctx.fillStyle='green'; pctx.beginPath(); pctx.arc(toCanvasX(s.Xcm), toCanvasY(s.Ycm),6,0,Math.PI*2); pctx.fill();
    pctx.fillStyle='blue'; pctx.beginPath(); pctx.arc(toCanvasX(e.Xcm), toCanvasY(e.Ycm),6,0,Math.PI*2); pctx.fill();
  }
}

// draw centered axes and dotted grid. If pts array given, auto-scale symmetric limits around zero.
function drawCenteredAxes(pts, onlyGrid){
  const W = plotCanvas.width, H = plotCanvas.height;
  // determine axis limits in cm (symmetric about 0)
  let maxRange = 20.0; // default ±20 cm
  if (pts && pts.length>0){
    let maxAbs = 0;
    for (const p of pts){ maxAbs = Math.max(maxAbs, Math.abs(p.x), Math.abs(p.y)); }
    if (maxAbs < 5) maxRange = 10;
    else maxRange = Math.ceil(maxAbs*1.2); // add margin
    // make symmetric and round up to nice number
    maxRange = Math.max(5, Math.ceil(maxRange));
  }
  const xmin = -maxRange, xmax = maxRange, ymin = -maxRange, ymax = maxRange;
  // transform world cm to canvas coordinates
  const scaleX = W / (xmax - xmin), scaleY = H / (ymax - ymin);
  function toCanvasX(x){ return (x - xmin) * scaleX; }
  function toCanvasY(y){ return H - (y - ymin) * scaleY; }

  // background
  pctx.fillStyle='#fff'; pctx.fillRect(0,0,W,H);

  // dotted grid: draw both major ticks every (maxRange/5) or 5 cm whichever reasonable
  const majorStep = Math.max(2, Math.round(maxRange/5));
  pctx.strokeStyle = '#cfd8e3';
  pctx.lineWidth = 1;
  pctx.setLineDash([2,6]);
  for (let x = xmin; x <= xmax; x += majorStep){
    const cx = toCanvasX(x);
    pctx.beginPath(); pctx.moveTo(cx,0); pctx.lineTo(cx,H); pctx.stroke();
  }
  for (let y = ymin; y <= ymax; y += majorStep){
    const cy = toCanvasY(y);
    pctx.beginPath(); pctx.moveTo(0,cy); pctx.lineTo(W,cy); pctx.stroke();
  }
  pctx.setLineDash([]);

  // draw axes lines at zero
  pctx.strokeStyle = '#000'; pctx.lineWidth = 1.2;
  // y-axis (x=0)
  const cx0 = toCanvasX(0), cy0 = toCanvasY(0);
  pctx.beginPath(); pctx.moveTo(cx0,0); pctx.lineTo(cx0,H); pctx.stroke();
  // x-axis (y=0)
  pctx.beginPath(); pctx.moveTo(0,cy0); pctx.lineTo(W,cy0); pctx.stroke();

  // axis ticks and labels (numerical ticks)
  pctx.fillStyle='#000'; pctx.font='12px Arial';
  // X-axis ticks
  for (let x = xmin; x <= xmax; x += majorStep){
    const cx = toCanvasX(x); pctx.fillText(x.toString(), cx-10, cy0+14);
  }
  // Y-axis ticks
  for (let y = ymin; y <= ymax; y += majorStep){
    const cy = toCanvasY(y);
    pctx.fillText(y.toString(), cx0+6, cy+4);
  }

  // axis labels (ML on x, AP on y)
  pctx.font='bold 14px Arial';
  pctx.fillText('ML COP (cm)', W/2 - 30, H - 6);
  // rotate for Y label
  pctx.save();
  pctx.translate(10, H/2 + 30);
  pctx.rotate(-Math.PI/2);
  pctx.fillText('AP COP (cm)', 0, 0);
  pctx.restore();

  // helper to return transformation functions (used by drawLiveSpaghetti)
  return [toCanvasX, toCanvasY, scaleX, {xmin,xmax,ymin,ymax}];
}

// helper to compute world->canvas transform for current pts
function worldToCanvasTransform(pts){
  const W = plotCanvas.width, H = plotCanvas.height;
  let maxAbs = 0;
  if (pts && pts.length>0) for (const p of pts) maxAbs = Math.max(maxAbs, Math.abs(p.x), Math.abs(p.y));
  if (maxAbs < 5) maxAbs = 10; else maxAbs = Math.ceil(maxAbs*1.2);
  const maxRange = Math.max(5, maxAbs);
  const xmin = -maxRange, xmax = maxRange, ymin = -maxRange, ymax = maxRange;
  const scaleX = W / (xmax - xmin), scaleY = H / (ymax - ymin);
  function toCanvasX(x){ return (x - xmin) * scaleX; }
  function toCanvasY(y){ return H - (y - ymin) * scaleY; }
  return [toCanvasX, toCanvasY, Math.min(scaleX, scaleY), {xmin,xmax,ymin,ymax}];
}

// LIVE metric display updated from liveData (but exported values use testData)
function updateLiveMetricsDisplay(){
  if (!liveData.length){ totalSwayEl.innerText='0.000'; swayAreaEl.innerText='0.000'; mlDistEl.innerText='0.000'; apDistEl.innerText='0.000'; return; }
  const xs = liveData.map(d=>d.Xcm), ys = liveData.map(d=>d.Ycm);
  // path length on liveData
  let path=0; for (let i=0;i<liveData.length-1;i++) path += Math.hypot(liveData[i+1].Xcm-liveData[i].Xcm, liveData[i+1].Ycm-liveData[i].Ycm);
  const mlDist = Math.max(...xs) - Math.min(...xs), apDist = Math.max(...ys) - Math.min(...ys);
  const hull = convexHull(xs.map((v,i)=>[xs[i],ys[i]])); const area = polygonArea(hull);
  totalSwayEl.innerText = path.toFixed(3); swayAreaEl.innerText = area.toFixed(3);
  mlDistEl.innerText = mlDist.toFixed(3); apDistEl.innerText = apDist.toFixed(3);
}

// convex hull and polygon area helpers (same as earlier)
function convexHull(points){ if (points.length <= 3) return points; points = points.map(p=>[p[0],p[1]]).sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0]); const cross=(o,a,b)=> (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0]); const lower=[]; for (const p of points){ while(lower.length>=2 && cross(lower[lower.length-2], lower[lower.length-1], p) <= 0) lower.pop(); lower.push(p);} const upper=[]; for (let i=points.length-1;i>=0;i--){ const p=points[i]; while(upper.length>=2 && cross(upper[upper.length-2], upper[upper.length-1], p) <= 0) upper.pop(); upper.push(p); } upper.pop(); lower.pop(); return lower.concat(upper); }
function polygonArea(poly){ if (!poly || poly.length<3) return 0; let a=0; for (let i=0;i<poly.length;i++){ const j=(i+1)%poly.length; a += poly[i][0]*poly[j][1] - poly[j][0]*poly[i][1]; } return Math.abs(a)/2.0; }

// Export functions: export the most recent testData (fresh buffer created on Start Test)
exportCSVBtn.onclick = ()=>{
  if (!testData.length){ alert('No test data: start a test first'); return; }
  let header = 'meta: px_per_cm=' + (pixelsPerCm?pixelsPerCm.toFixed(3):'NA') + '\\n';
  header += 't_s,px_x,px_y,X_cm,Y_cm,sway_cm\\n';
  const rows = testData.map(d=>[d.t.toFixed(3), d.px_x.toFixed(2), d.px_y.toFixed(2), d.Xcm.toFixed(3), d.Ycm.toFixed(3), d.sway.toFixed(3)].join(',')).join('\\n');
  const csv = header + rows; const blob = new Blob([csv], {type:'text/csv'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='sway_test.csv'; a.click(); setTimeout(()=>URL.revokeObjectURL(a.href),1500);
};

exportPlotBtn.onclick = ()=>{
  if (!testData.length){ alert('No test data: start a test first'); return; }
  // render the testData on a temporary canvas in the same centered axes style, and export as PNG
  const tmp = document.createElement('canvas'); tmp.width = plotCanvas.width; tmp.height = plotCanvas.height; const tctx = tmp.getContext('2d');
  // draw axes (reuse worldToCanvasTransform)
  const pts = testData.map(d=>({x:d.Xcm,y:d.Ycm}));
  // draw axes and dotted grid
  // --- reuse transformation logic from drawCenteredAxes by borrowing worldToCanvasTransform
  const [toCanvasX,toCanvasY,scale,off] = (function(ptsInner){
    const W=tmp.width, H=tmp.height; let maxAbs=0;
    for(const p of ptsInner) maxAbs=Math.max(maxAbs, Math.abs(p.x), Math.abs(p.y));
    if(maxAbs<5) maxAbs=10; else maxAbs=Math.ceil(maxAbs*1.2);
    const maxRange=Math.max(5,maxAbs); const xmin=-maxRange, xmax=maxRange, ymin=-maxRange, ymax=maxRange;
    const scaleX = W/(xmax-xmin), scaleY = H/(ymax-ymin);
    function tx(x){ return (x - xmin) * scaleX; } function ty(y){ return H - (y - ymin) * scaleY; }
    return [tx,ty,Math.min(scaleX,scaleY),{xmin,xmax,ymin,ymax}];
  })(pts);
  // bg + grid dotted
  tctx.fillStyle='#fff'; tctx.fillRect(0,0,tmp.width,tmp.height);
  tctx.strokeStyle='#cfd8e3'; tctx.setLineDash([2,6]);
  const step = Math.max(2, Math.round((off.xmax-off.xmin)/5));
  for(let x=off.xmin; x<=off.xmax; x+=step){ const cx = toCanvasX(x); tctx.beginPath(); tctx.moveTo(cx,0); tctx.lineTo(cx,tmp.height); tctx.stroke(); }
  for(let y=off.ymin; y<=off.ymax; y+=step){ const cy = toCanvasY(y); tctx.beginPath(); tctx.moveTo(0,cy); tctx.lineTo(tmp.width,cy); tctx.stroke(); }
  tctx.setLineDash([]); tctx.strokeStyle='#000'; tctx.lineWidth=1.4;
  // path
  tctx.beginPath();
  for(let i=0;i<pts.length;i++){ const nx=toCanvasX(pts[i].x), ny=toCanvasY(pts[i].y); if(i===0) tctx.moveTo(nx,ny); else tctx.lineTo(nx,ny); }
  tctx.stroke();
  // start end markers
  tctx.fillStyle='green'; tctx.beginPath(); tctx.arc(toCanvasX(pts[0].x), toCanvasY(pts[0].y),6,0,Math.PI*2); tctx.fill();
  tctx.fillStyle='blue'; tctx.beginPath(); tctx.arc(toCanvasX(pts[pts.length-1].x), toCanvasY(pts[pts.length-1].y),6,0,Math.PI*2); tctx.fill();
  // export
  const link = document.createElement('a'); link.href = tmp.toDataURL('image/png'); link.download='sway_plot_test.png'; link.click();
};

// Test controls: Start Test clears testData (fresh) and sets measuring=true; Stop Test ends measuring
let testTimer = null;
startRecBtn.onclick = ()=>{
  if (!baselineMid && !pixelsPerCm){ alert('Set midpoint & calibrate markers first'); return; }
  testData = []; measuring = true; let remaining = 30; timerEl.innerText = 'Timer: '+remaining+'s';
  testTimer = setInterval(()=>{ remaining -= 1; timerEl.innerText = 'Timer: '+remaining+'s'; if(remaining<=0){ clearInterval(testTimer); stopRec(); } }, 1000);
};
stopRecBtn.onclick = ()=>{ if(testTimer) clearInterval(testTimer); stopRec(); };
function stopRec(){ measuring=false; timerEl.innerText='Timer: --'; alert('Test finished — exportable now'); }

// Periodic auto-redetect
setInterval(()=>{ if (videoReady && (markers.length<2 || performance.now()-lastGoodTimestamp>3000)) attemptAutoRedetect(); }, 2000);

function attemptAutoRedetect(){
  detectBlobs().then(res=>{
    const blobs = res.blobs;
    if (blobs.length>=2){
      const b1=blobs[0], b2=blobs[1]; const sx = overlay.width / res.pw, sy = overlay.height / res.ph;
      markers = [{x:b1.cx*sx,y:b1.cy*sy},{x:b2.cx*sx,y:b2.cy*sy}];
      pixelsPerCm = Math.hypot(markers[0].x-markers[1].x, markers[0].y-markers[1].y)/30.0;
      if (!baselineMid) baselineMid = {x:(markers[0].x+markers[1].x)/2, y:(markers[0].y+markers[1].y)/2, unit:'px'};
      lastGoodTimestamp = performance.now();
    }
  }).catch(e=>console.warn('auto redetect fail',e));
}

// drawLiveSpaghetti wraps drawCenteredAxes + path; liveData is used (continuous)
function drawLiveSpaghetti_old(){} // placeholder

// start loop
video.addEventListener('loadedmetadata', ()=>{ ensureOverlaySize(); videoReady=true; requestAnimationFrame(loop); });
requestAnimationFrame(loop);

</script>
</body>
</html>
